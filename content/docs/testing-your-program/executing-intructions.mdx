---
title: Executing Instructions
description: Learn how call an instruction from A Solana program in your test
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

## Overview

After deploying a program to LiteSVM, you'll need to execute instructions to interact with the deployed program.

LiteSVM provides a simple API for creating, sending, and simulating transactions that is fully compatible with Solana's transaction model.

## Basic Transaction Flow

The typical flow for executing an instruction is:

1. **Create an Instruction** - Define what program to call and with what data
2. **Build a Message** - Combine one or more instructions
3. **Create a Transaction** - Sign the message with required signers
4. **Send or Simulate** - Execute the transaction and handle results

## Creating Instructions

### Basic Instruction Structure

```rust
use solana_instruction::{Instruction, AccountMeta};
use solana_pubkey::Pubkey;

let instruction = Instruction {
    program_id: Pubkey::new_unique(),  // The program to call
    accounts: vec![                     // Accounts the program needs
        AccountMeta::new(account_pubkey, false),        // Writable, not signer
        AccountMeta::new_readonly(readonly_pubkey, false), // Read-only, not signer
        AccountMeta::new(signer_pubkey, true),          // Writable, signer
    ],
    data: vec![0, 1, 2, 3],             // Instruction data (program-specific)
};
```

## Building and Sending Transactions

### Method 1: Simple Transaction

```rust
use litesvm::LiteSVM;
use solana_keypair::Keypair;
use solana_message::Message;
use solana_transaction::Transaction;
use solana_signer::Signer;

let mut svm = LiteSVM::new();
let payer = Keypair::new();

// Airdrop SOL for fees
svm.airdrop(&payer.pubkey(), 1_000_000_000).unwrap();

// Create instruction
let instruction = /* your instruction */;

// Build message with payer
let message = Message::new(&[instruction], Some(&payer.pubkey()));

// Create and sign transaction
let tx = Transaction::new(
    &[&payer],                  // Signers
    message,                    // Message
    svm.latest_blockhash(),     // Recent blockhash
);

// Send transaction
let result = svm.send_transaction(tx);
```

### Method 2: Transaction with Multiple Signers

```rust
let payer = Keypair::new();
let authority = Keypair::new();

let message = Message::new(&[instruction], Some(&payer.pubkey()));
let tx = Transaction::new(
    &[&payer, &authority],      // Multiple signers
    message,
    svm.latest_blockhash(),
);

let result = svm.send_transaction(tx);
```

### Method 3: Transaction with Explicit Blockhash

```rust
let blockhash = svm.latest_blockhash();
let message = Message::new_with_blockhash(
    &[instruction],
    Some(&payer.pubkey()),
    &blockhash,
);
let tx = Transaction::new(&[&payer], message, blockhash);
```

## Versioned Transactions

LiteSVM supports both legacy and versioned transactions:

```rust
use solana_transaction::versioned::VersionedTransaction;
use solana_message::VersionedMessage;

// Legacy transaction (most common)
let legacy_msg = Message::new(&[instruction], Some(&payer.pubkey()));
let versioned_tx = VersionedTransaction::try_new(
    VersionedMessage::Legacy(legacy_msg),
    &[&payer]
).unwrap();

// Send versioned transaction
let result = svm.send_transaction(versioned_tx);
```

## Transaction Results

### Successful Transaction

```rust
match svm.send_transaction(tx) {
    Ok(meta) => {
        println!("Signature: {}", meta.signature);
        println!("Compute units: {}", meta.compute_units_consumed);
        println!("Logs:");
        for log in &meta.logs {
            println!("  {}", log);
        }

        // Access return data if program returns any
        if let Some(data) = meta.return_data.data {
            println!("Return data: {:?}", data);
        }
    }
    Err(err) => {
        println!("Transaction failed: {:?}", err.err);
        // Logs are still available on failure
        println!("Failure logs: {:?}", err.meta.logs);
    }
}
```

### Transaction Metadata Fields

```rust
pub struct TransactionMetadata {
    pub signature: Signature,              // Transaction signature
    pub logs: Vec<String>,                  // Program logs
    pub compute_units_consumed: u64,       // CUs used
    pub return_data: TransactionReturnData, // Data returned by program
    pub inner_instructions: InnerInstructionsList, // CPI calls
}
```

## Simulating Transactions

Simulation lets you test transactions without changing state:

```rust
// Simulate instead of sending
match svm.simulate_transaction(tx) {
    Ok(sim_result) => {
        println!("Simulation successful!");
        println!("Logs: {:?}", sim_result.meta.logs);
        println!("Compute units: {}", sim_result.meta.compute_units_consumed);

        // Access post-simulation account states
        for (pubkey, account) in sim_result.post_accounts {
            println!("Account {} has {} lamports", pubkey, account.lamports);
        }
    }
    Err(err) => {
        println!("Simulation failed: {:?}", err.err);
    }
}
```

## Error Handling

### Common Transaction Errors

```rust
use solana_transaction_error::TransactionError;
use solana_instruction::error::InstructionError;

match svm.send_transaction(tx) {
    Err(failed_tx) => {
        match failed_tx.err {
            TransactionError::InsufficientFundsForFee => {
                println!("Not enough SOL for fees");
            }
            TransactionError::InvalidProgramForExecution => {
                println!("Program doesn't exist or isn't executable");
            }
            TransactionError::InstructionError(index, err) => {
                println!("Instruction {} failed: {:?}", index, err);
                match err {
                    InstructionError::Custom(code) => {
                        println!("Custom error code: {}", code);
                    }
                    InstructionError::AccountNotFound => {
                        println!("An account doesn't exist");
                    }
                    _ => {}
                }
            }
            TransactionError::BlockhashNotFound => {
                println!("Blockhash expired or invalid");
            }
            _ => println!("Other error: {:?}", failed_tx.err),
        }
    }
    Ok(_) => {}
}
```

## Working with Program Logs

### Accessing Logs

```rust
let result = svm.send_transaction(tx).unwrap();

// All logs (including system logs)
for log in &result.logs {
    println!("{}", log);
}

// Pretty-printed logs (formatted)
println!("{}", result.pretty_logs());
```

### Log Output Example

```
Program 11111111111111111111111111111111 invoke [1]
Program log: Processing instruction
Program 11111111111111111111111111111111 consumed 2000 compute units
Program 11111111111111111111111111111111 success
```

## Compute Budget Configuration

### Setting Global Compute Budget

```rust
use solana_compute_budget::compute_budget::ComputeBudget;

let mut svm = LiteSVM::new()
    .with_compute_budget(ComputeBudget {
        compute_unit_limit: 200_000,
        ..Default::default()
    });
```

### Per-Transaction Compute Budget

```rust
use solana_compute_budget_interface::ComputeBudgetInstruction;

let instructions = vec![
    // Set compute budget for this transaction
    ComputeBudgetInstruction::set_compute_unit_limit(400_000),
    ComputeBudgetInstruction::set_compute_unit_price(1),

    // Your actual instruction
    your_instruction,
];

let tx = Transaction::new(
    &[&payer],
    Message::new(&instructions, Some(&payer.pubkey())),
    svm.latest_blockhash(),
);
```

## Complete Example: Counter Program

```rust
use litesvm::LiteSVM;
use solana_keypair::Keypair;
use solana_pubkey::Pubkey;
use solana_signer::Signer;
use solana_instruction::{Instruction, AccountMeta};
use solana_message::Message;
use solana_transaction::Transaction;
use solana_account::Account;

fn test_counter_program() {
    let mut svm = LiteSVM::new();

    // Setup accounts
    let payer = Keypair::new();
    let program_id = Pubkey::new_unique();
    let counter_account = Pubkey::new_unique();

    // Deploy program
    let program_bytes = include_bytes!("counter.so");
    svm.add_program(program_id, program_bytes).unwrap();

    // Fund payer
    svm.airdrop(&payer.pubkey(), 10_000_000).unwrap();

    // Initialize counter account
    svm.set_account(
        counter_account,
        Account {
            lamports: 1_000_000,
            data: vec![0u8; 8],  // 8 bytes for u64 counter
            owner: program_id,
            executable: false,
            rent_epoch: 0,
        },
    ).unwrap();

    // Create increment instruction
    let increment_ix = Instruction {
        program_id,
        accounts: vec![
            AccountMeta::new(counter_account, false),  // Counter account (writable)
            AccountMeta::new_readonly(payer.pubkey(), true), // Payer (signer)
        ],
        data: vec![1],  // Instruction: 1 = increment
    };

    // Build and send transaction
    let message = Message::new(&[increment_ix], Some(&payer.pubkey()));
    let tx = Transaction::new(&[&payer], message, svm.latest_blockhash());

    let result = svm.send_transaction(tx).unwrap();

    // Check results
    println!("Transaction succeeded!");
    println!("Signature: {}", result.signature);
    println!("Logs: {:?}", result.logs);

    // Verify counter was incremented
    let counter_data = svm.get_account(&counter_account).unwrap().data;
    let count = u64::from_le_bytes(counter_data[..8].try_into().unwrap());
    assert_eq!(count, 1);
}
```

## System Program Instructions

LiteSVM includes system program support:

```rust
use solana_system_interface::instruction::{transfer, create_account};

// Transfer SOL
let transfer_ix = transfer(
    &from_pubkey,
    &to_pubkey,
    1_000_000,  // lamports
);

// Create new account
let create_ix = create_account(
    &payer_pubkey,
    &new_account_pubkey,
    lamports,
    space as u64,
    &owner_program_id,
);
```

## Best Practices

### 1. Always Check Transaction Results

```rust
match svm.send_transaction(tx) {
    Ok(meta) => {
        // Success - but still check logs for warnings
        if meta.logs.iter().any(|log| log.contains("warning")) {
            println!("Transaction succeeded with warnings");
        }
    }
    Err(e) => {
        // Always log the error for debugging
        eprintln!("Transaction failed: {:?}", e);
        eprintln!("Logs: {:?}", e.meta.logs);
    }
}
```

### 2. Simulate Before Sending

```rust
// Simulate first to check for errors
if let Err(e) = svm.simulate_transaction(tx.clone()) {
    eprintln!("Simulation failed: {:?}", e);
    return;
}

// If simulation passes, send the actual transaction
let result = svm.send_transaction(tx).unwrap();
```

### 3. Manage Blockhashes

```rust
// Get fresh blockhash for each transaction
let blockhash = svm.latest_blockhash();

// Or expire blockhash to test error handling
svm.expire_blockhash();
```

### 4. Proper Account Setup

```rust
// Ensure accounts exist and have enough lamports
let min_balance = svm.minimum_balance_for_rent_exemption(data.len());
if svm.get_balance(&account).unwrap_or(0) < min_balance {
    svm.airdrop(&account, min_balance).unwrap();
}
```

## Disabling Signature Verification

For testing, you can disable signature verification:

```rust
let mut svm = LiteSVM::new()
    .with_sigverify(false);  // Disables signature checking

// Transactions will pass even with invalid signatures
```

## Summary

Executing instructions in LiteSVM follows the standard Solana transaction model:

1. Create `Instruction` objects with program ID, accounts, and data
2. Build a `Message` combining instructions with a fee payer
3. Create a `Transaction` with required signers
4. Use `send_transaction()` to execute or `simulate_transaction()` to test
5. Handle results by checking the `TransactionMetadata` or error details

LiteSVM provides instant execution with detailed logs and debugging information, making it ideal for testing Solana programs efficiently.
