---
title: Test Helpers
description: Account creation, token operations, PDA derivation, and slot management utilities
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

## Create Funded Accounts

The most common testing need is creating accounts with SOL. The `TestHelpers` trait makes this trivial.

### Single Account

```rust
use litesvm::LiteSVM;
use litesvm_utils::TestHelpers;
use solana_sdk::native_token::LAMPORTS_PER_SOL;

#[test]
fn test_create_funded_account() {
    let mut svm = LiteSVM::new();

    // Create a funded account with 10 SOL
    let alice = svm.create_funded_account(10 * LAMPORTS_PER_SOL);

    // The keypair is ready to use immediately
    println!("Alice's pubkey: {}", alice.pubkey());
}
```

### Multiple Accounts

```rust
use litesvm::LiteSVM;
use litesvm_utils::TestHelpers;
use solana_sdk::native_token::LAMPORTS_PER_SOL;

#[test]
fn test_create_multiple_accounts() {
    let mut svm = LiteSVM::new();

    // Create 5 funded accounts, each with 5 SOL
    let accounts = svm.create_funded_accounts(5, 5 * LAMPORTS_PER_SOL);

    assert_eq!(accounts.len(), 5);

    for (i, account) in accounts.iter().enumerate() {
        println!("Account {}: {}", i, account.pubkey());
    }
}
```

## Token Operations

Create token mints and accounts without the usual boilerplate.

### Create a Token Mint

```rust
use litesvm::LiteSVM;
use litesvm_utils::TestHelpers;
use solana_sdk::native_token::LAMPORTS_PER_SOL;

#[test]
fn test_create_token_mint() {
    let mut svm = LiteSVM::new();

    // Create authority account
    let authority = svm.create_funded_account(10 * LAMPORTS_PER_SOL);

    // Create a token mint with 9 decimals
    let mint = svm.create_token_mint(&authority, 9);

    println!("Mint address: {}", mint);
}
```

### Create Token Accounts

```rust
use litesvm::LiteSVM;
use litesvm_utils::TestHelpers;
use solana_sdk::native_token::LAMPORTS_PER_SOL;

#[test]
fn test_create_token_accounts() {
    let mut svm = LiteSVM::new();

    let authority = svm.create_funded_account(10 * LAMPORTS_PER_SOL);
    let user = svm.create_funded_account(5 * LAMPORTS_PER_SOL);

    // Create mint
    let mint = svm.create_token_mint(&authority, 9);

    // Create a regular token account
    let token_account = svm.create_token_account(&mint, &user);

    // Or create an Associated Token Account (ATA)
    let ata = svm.create_associated_token_account(&mint, &user);

    println!("Token account: {}", token_account);
    println!("ATA: {}", ata);
}
```

<Callout type="tip">
  **Use ATAs for most cases.** Associated Token Accounts are deterministic and follow Solana conventions. Use regular token accounts only when you need multiple accounts for the same mint/owner pair.
</Callout>

### Mint Tokens

```rust
use litesvm::LiteSVM;
use litesvm_utils::{TestHelpers, AssertionHelpers};
use solana_sdk::native_token::LAMPORTS_PER_SOL;

#[test]
fn test_mint_tokens() {
    let mut svm = LiteSVM::new();

    let authority = svm.create_funded_account(10 * LAMPORTS_PER_SOL);
    let user = svm.create_funded_account(5 * LAMPORTS_PER_SOL);

    // Create mint with authority
    let mint = svm.create_token_mint(&authority, 9);

    // Create ATA for user
    let user_ata = svm.create_associated_token_account(&mint, &user);

    // Mint 1000 tokens to user's ATA
    svm.mint_to(&mint, &user_ata, &authority, 1000);

    // Verify the balance
    svm.assert_token_balance(&user_ata, 1000);
}
```

## PDA Derivation

Derive Program Derived Addresses easily for your tests.

### Basic PDA Derivation

```rust
use litesvm::LiteSVM;
use litesvm_utils::TestHelpers;
use solana_sdk::pubkey::Pubkey;

#[test]
fn test_derive_pda() {
    let mut svm = LiteSVM::new();

    let program_id = Pubkey::new_unique();
    let user = Pubkey::new_unique();

    // Get PDA with bump
    let (pda, bump) = svm.derive_pda(
        &[b"user_account", user.as_ref()],
        &program_id,
    );

    println!("PDA: {}, Bump: {}", pda, bump);
}
```

### Get Just the PDA

```rust
use litesvm::LiteSVM;
use litesvm_utils::TestHelpers;
use solana_sdk::pubkey::Pubkey;

#[test]
fn test_get_pda() {
    let mut svm = LiteSVM::new();

    let program_id = Pubkey::new_unique();

    // When you don't need the bump
    let pda = svm.get_pda(&[b"config"], &program_id);

    println!("Config PDA: {}", pda);
}
```

<Callout type="info">
  Use `derive_pda` when you need the bump seed (e.g., for CPI calls). Use `get_pda` when you only need the address.
</Callout>

## Slot Management

Control time progression for testing time-dependent logic.

### Get Current Slot

```rust
use litesvm::LiteSVM;
use litesvm_utils::TestHelpers;

#[test]
fn test_get_current_slot() {
    let mut svm = LiteSVM::new();

    let slot = svm.get_current_slot();
    println!("Current slot: {}", slot);
}
```

### Advance Slots

```rust
use litesvm::LiteSVM;
use litesvm_utils::TestHelpers;

#[test]
fn test_advance_slots() {
    let mut svm = LiteSVM::new();

    let initial_slot = svm.get_current_slot();

    // Advance by 100 slots
    svm.advance_slot(100);

    let new_slot = svm.get_current_slot();
    assert_eq!(new_slot, initial_slot + 100);
}
```

## Complete Example

Here's a comprehensive example using multiple test helpers together:

```rust
use litesvm::LiteSVM;
use litesvm_utils::{TestHelpers, AssertionHelpers};
use solana_sdk::native_token::LAMPORTS_PER_SOL;

#[test]
fn test_complete_setup() {
    let mut svm = LiteSVM::new();

    // Create accounts
    let admin = svm.create_funded_account(100 * LAMPORTS_PER_SOL);
    let users = svm.create_funded_accounts(3, 10 * LAMPORTS_PER_SOL);

    // Create token infrastructure
    let mint = svm.create_token_mint(&admin, 6); // 6 decimals like USDC

    // Create ATAs and mint tokens to each user
    for (i, user) in users.iter().enumerate() {
        let ata = svm.create_associated_token_account(&mint, user);
        let amount = (i as u64 + 1) * 1_000_000; // 1, 2, 3 tokens
        svm.mint_to(&mint, &ata, &admin, amount);

        // Verify
        svm.assert_token_balance(&ata, amount);
    }

    // Verify total supply
    let total_supply = 1_000_000 + 2_000_000 + 3_000_000;
    svm.assert_mint_supply(&mint, total_supply);

    // Test time-based logic
    let start_slot = svm.get_current_slot();
    svm.advance_slot(1000);
    assert!(svm.get_current_slot() > start_slot);
}
```
