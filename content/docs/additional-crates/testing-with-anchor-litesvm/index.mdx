---
title: Quick Start
description: Learn how to use anchor-litesvm for testing Anchor programs with simplified syntax
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

<div className="flex items-center gap-3 mb-6">
  <a
    href="https://crates.io/crates/anchor-litesvm"
    target="_blank"
    rel="noopener noreferrer"
    className="inline-flex items-center gap-2 px-3 py-1.5 bg-fd-muted/50 hover:bg-fd-muted rounded-lg text-sm font-medium transition-colors border border-fd-border/50"
  >
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" className="w-4 h-4" fill="currentColor">
      <path d="M239.1 6.3l-208 78c-18.7 7-31.1 25-31.1 45v225.1c0 18.2 10.3 34.8 26.5 42.9l208 104c13.5 6.8 29.4 6.8 42.9 0l208-104c16.3-8.1 26.5-24.8 26.5-42.9V129.3c0-20-12.4-37.9-31.1-44.9l-208-78C262 2.2 250 2.2 239.1 6.3zM256 68.4l192 72v1.1l-192 78-192-78v-1.1l192-72zm32 356V275.5l160-65v133.9l-160 80z"/>
    </svg>
    View <code>anchor-litesvm</code> on crates.io
  </a>
</div>

## Installation

Make sure you have all the needed dependencies:

```bash
cargo add --dev anchor-litesvm litesvm solana-sdk
```

## What is anchor-litesvm?

The `anchor-litesvm` crate provides a **simplified syntax similar to anchor-client** but without RPC overhead. It achieves **78% code reduction** compared to raw LiteSVM while maintaining type safety with Anchor types.

<Steps>
<Step>
**AnchorContext**
- Production-compatible test context
- Same API patterns as anchor-client
- Manages LiteSVM instance, payer, and program
- Execute instructions without RPC overhead
</Step>

<Step>
**Program API**
- Fluent instruction building
- Type-safe account and argument handling
- Familiar anchor-client syntax
</Step>

<Step>
**Account Deserialization**
- Fetch and deserialize Anchor accounts
- Automatic discriminator handling
- Support for PDAs and custom layouts
</Step>

<Step>
**Event Parsing**
- Parse events from transaction logs
- Assert event emission
- Type-safe event deserialization
</Step>
</Steps>

## Quick Example

Here's a complete example showing the power of anchor-litesvm:

```rust
use anchor_litesvm::{AnchorLiteSVM, AnchorContext};
use anchor_lang::prelude::*;
use solana_sdk::{
    native_token::LAMPORTS_PER_SOL,
    signature::Signer,
};

// Your Anchor program's ID
declare_id!("YourProgramId11111111111111111111111111111");

#[test]
fn test_anchor_program() {
    // Build test context with your program
    let ctx: AnchorContext = AnchorLiteSVM::new()
        .deploy_program(id(), include_bytes!("../target/deploy/your_program.so"))
        .build();

    // Create a funded account
    let user = ctx.create_funded_account(10 * LAMPORTS_PER_SOL);

    // Build and execute an instruction using familiar anchor-client syntax
    let ix = ctx.program()
        .accounts(Initialize {
            user: user.pubkey(),
            system_program: solana_sdk::system_program::id(),
        })
        .args(instruction::Initialize {
            name: "test".to_string()
        })
        .instruction()
        .unwrap();

    // Execute the instruction
    ctx.execute_instruction(ix, &[&user]).unwrap();

    // Fetch and deserialize the account
    let account: UserAccount = ctx.get_account(&user_pda).unwrap();
    assert_eq!(account.name, "test");
}
```

## Comparison: Raw LiteSVM vs anchor-litesvm

### Before (Raw LiteSVM)

```rust
use litesvm::LiteSVM;
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    message::Message,
    transaction::Transaction,
};

let mut svm = LiteSVM::new();
svm.add_program(program_id, program_bytes);

let payer = Keypair::new();
svm.airdrop(&payer.pubkey(), 10 * LAMPORTS_PER_SOL).unwrap();

// Manually build instruction data with discriminator
let mut data = Vec::new();
data.extend_from_slice(&anchor_lang::idl::DISCRIMINATOR);
data.extend_from_slice(&args.try_to_vec().unwrap());

let accounts = vec![
    AccountMeta::new(user, true),
    AccountMeta::new_readonly(system_program::id(), false),
];

let ix = Instruction::new_with_bytes(program_id, &data, accounts);

let message = Message::new(&[ix], Some(&payer.pubkey()));
let tx = Transaction::new(&[&payer], message, svm.latest_blockhash());
svm.send_transaction(tx).unwrap();

// Manually deserialize with discriminator handling
let account_data = svm.get_account(&pda).unwrap().data;
let account: UserAccount = UserAccount::try_deserialize(&mut &account_data[8..]).unwrap();
```

### After (anchor-litesvm)

```rust
use anchor_litesvm::{AnchorLiteSVM, AnchorContext};

let ctx = AnchorLiteSVM::build_with_program(program_id, program_bytes);
let user = ctx.create_funded_account(10 * LAMPORTS_PER_SOL);

let ix = ctx.program()
    .accounts(Initialize { user: user.pubkey(), system_program: system_program::id() })
    .args(instruction::Initialize { name: "test".to_string() })
    .instruction()
    .unwrap();

ctx.execute_instruction(ix, &[&user]).unwrap();

let account: UserAccount = ctx.get_account(&pda).unwrap();
```

## Key Components

### AnchorLiteSVM Builder

| Method | Description |
| ------ | ----------- |
| `new()` | Creates a new builder instance |
| `with_payer(keypair)` | Sets a custom payer keypair |
| `deploy_program(id, bytes)` | Adds a program to deploy |
| `build()` | Builds the AnchorContext |
| `build_with_program(id, bytes)` | Convenience for single program |
| `build_with_programs(programs)` | Deploy multiple programs |

### AnchorContext

| Method | Description |
| ------ | ----------- |
| `program()` | Returns Program for instruction building |
| `execute_instruction(ix, signers)` | Execute a single instruction |
| `execute_instructions(ixs, signers)` | Execute multiple instructions |
| `get_account<T>(pubkey)` | Fetch and deserialize account |
| `create_funded_account(lamports)` | Create a funded keypair |
| `payer()` | Get the payer keypair |
| `airdrop(pubkey, lamports)` | Airdrop SOL to an address |

### Program

| Method | Description |
| ------ | ----------- |
| `accounts(accounts)` | Set instruction accounts |
| `args(args)` | Set instruction arguments |
| `instruction()` | Build the final instruction |
| `id()` | Get the program ID |

## Troubleshooting

### Common Errors

| Error | Cause | Solution |
| ----- | ----- | -------- |
| `AccountNotFound` | Account doesn't exist | Ensure account is created before fetching |
| `DiscriminatorMismatch` | Wrong account type | Verify you're using the correct account struct |
| `DeserializationError` | Invalid account data | Check account was initialized correctly |
| No programs added | Called `build()` without `deploy_program()` | Add at least one program before building |
